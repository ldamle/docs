---
description: Сигнал - состояние соединения.
icon: binary
---

# Signal

## Сигнал

Соединение может находиться в 4 состояниях:

* **0 -** Логический ноль
* **1 -** Логическая единица
* **x -** Любое
* **z** - Высокого импеданса

У одного соединения обязательно будет только одно состояния (длинные линии не рассматриваются).

```typescript
let signal0: ldamle.Types.signal.it = 0;
let signalz: ldamle.Types.signal.it = 'z';
```

## Массив сигналов

Массив сигналов - массив состояний соединений (чаще всего на входах/выходах одного элемента).

Задается в виде строки. Длина строки - количество соединений.

```typescript
let signal_in: ldamle.Types.signal.array = '1110111';
```

## Состояния

При задании элемента необходимо описать его поведение, т.е. как он будет обрабатывать входные сигналы и что у него будет на выходе.

Выходные сигналы могут быть только 0 или 1. Если хотя бы один входной сигнал - z, то выходные сигналы будут z.

Входным сигналом может служить любой из 4 сигналов.

### Таблица истинности

Один из способов задания зависимости выходных сигналов элемента от входных - таблица истинности. Задается как `ldamle.Types.signal.array[]` .

```typescript
let state: ldamle.Types.signal.array[] = [
    '101',
    '110',
    '001',
    '100'
];
```

В данном примере заданы 4 выходных состояния. Вот вся таблица истинности для данного элемента:

| Вход | Выход |
| ---- | ----- |
| 00   | 101   |
| 01   | 110   |
| 10   | 001   |
| 11   | 100   |

Таким образом длина данного массива массивов сигналов должна быть 2^in, где in - количество входных соединений элемента. Длина каждого из массивов сигналов должна быть разна количеству выходных соединений элемента.

Выходные сигналы задаются в строго определенной последовательности, поэтому входные сигналы опускаются.

### Полная таблица истинности

Если необходимо задать выходные сигналы в другой последовательности или задать не все можно воспользоваться полной таблицей истинности.

```typescript
let state: ldamle.Types.signal.detail = [
    {in: '00x', out: '11'};
    {in: '01x', out: '10'};
    {in: '10x', out: '01'};
    {in: '11x', out: '00'};
];
```

| Вход | Выход |
| ---- | ----- |
| 000  | 11    |
| 001  | 11    |
| 010  | 10    |
| 011  | 10    |
| 100  | 01    |
| 101  | 01    |
| 110  | 00    |
| 111  | 00    |

Длина массива входных сигналов должна быть равна количеству входных соединений элемента. Длина массива выходных сигналов должна быть равна количеству выходных соединений элемента.

### Упрощенный способ задания

Если в элементе присутствует управляющий сигнал(ы), то состояния легче задать этим способом.

```typescript
const stateArray1: stateArray = [
    {name: 'E_n', state:0, out: '0000'},
    {name: 'A', state:0, out: {name: 'B', state:0, out: '0001'},},
    {name: 'else', state:'x', out: '1100'}
];
```

| E\_n | A | B | Выход |
| ---- | - | - | ----- |
| 0    | x | x | 0000  |
| 1    | 0 | 0 | 0001  |
| 1    | 0 | 1 | 1100  |
| 1    | 1 | 0 | 1100  |
| 1    | 1 | 1 | 1100  |

В поле name пишется название входа. Если на этом входе сигнал будет равен `state`, то независимо от других входов у элемента выходные сигналы будут `out`.

По правилу первого состояния остальных элементов игнорируются, даже если возникает противоречие. Допустимо вложенное задание состояний (см. пример выше).

Если `name` - `else`, то все еще не заданные пары входных-выходных состояний становятся:

* `out`, если `state = 'x'`
* `state`

### Общий способ задания

Допустимо задавать пары входных-выходных состояний общим способом - комбинируя все способы, описанные ранее. Если возникают противоречия, то сначала заполняется детальный способ, а затем оставшиеся упрощенный. Обычная таблица истинности заполняется поиском незаполненных значений, что становится сложнее отследить, если использовать ее в комбинации с остальными способами.

```typescript
 const DSSSArray1: detailStateArray = [
      '1010',   // Таблица истинности
      {name: 'E_n', state: 0, out: '0000']], // Упрощенный способ
      {in: '110', out: '0100'}, // Полная таблица истинности
      {name: 'else', state: 'x', out: '1100']  // Упрощенный способ
 ];
```

| A | B | E\_n | Выход |
| - | - | ---- | ----- |
| 0 | 0 | 0    | 0000  |
| 0 | 1 | 0    | 0000  |
| 1 | 0 | 0    | 0000  |
| 1 | 1 | 0    | 0100  |
| 0 | 0 | 1    | 1010  |
| 0 | 1 | 1    | 1100  |
| 1 | 0 | 1    | 1100  |
| 1 | 1 | 1    | 1100  |

Порядок строк изменен для наглядности. Сначала заполнился весь способ Полной таблицы истинности, затем упрощенный кроме `else`, потом на первое незаполненное место встали выходные сигналы способа Таблицы истинности и в конце, в остальные незаполненные строки встали сигналы `out` из `else`.

## Функция

Все состояния в итоге приводятся к функции, которая в зависимости от входных состояний (и не только), выдает выходные состояния элемента. Данную функцию можно задать и самостоятельно.

```typescript
function (in_signals: ldamle.Types.signal.array): ldamle.Types.signal.array {
  return "0000100010";
}
```

Выходы элемента всегда будут `0000100010` в независимости от входных сигналов.

Функция хранится в поле `state` класса `Element`.
